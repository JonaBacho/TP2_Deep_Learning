name: Deploy Application

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: 'staging'
  push:
    branches:
      - main
    paths:
      - 'src/app.py'
      - 'Dockerfile'
      - 'requirements.txt'
      - '.github/workflows/deploy.yml'

env:
  REGISTRY: ghcr.io
  APP_NAME: mnist-improdved-mlflow-app
  HEALTH_DELAY: ${{ secrets.DEPLOY_DELAY }}
  CONTAINER_NAME: mnist-improved-mlflow-app
  #IMAGE_NAME: ghcr.io/$(echo $GITHUB_REPOSITORY | tr '[:upper:]' '[:lower:]')/mnist-mlflow-app

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_name: ${{ steps.prep.outputs.image_name }}
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3

    - name: Prepare environment variables
      id: prep
      run: |
        # Convertir le repository en minuscules
        IMAGE_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        echo "image_name=ghcr.io/${IMAGE_NAME}/mnist-improved-mlflow-app" >> $GITHUB_OUTPUT
        echo "Image name: ghcr.io/${IMAGE_NAME}/mnist-imporoved-mlflow-app"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ steps.prep.outputs.image_name }} #${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          PYTHON_VERSION=3.10
    
    - name: Image Digest
      run: echo ${{ steps.meta.outputs.digest }}

  test:
    name: Test Docker Image
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Pull Docker Image
      run: |
        docker pull ${{ needs.build.outputs.image_name }}
    
    - name: Test Container Health
      run: |
        docker run -d --name test-app \
          -e MLFLOW_TRACKING_URI=http://test \
          -e MODEL_NAME=mnist-classifier \
          -p 5000:5000 \
          ${{ needs.build.outputs.image_name }}
        
        # Attendre que le conteneur démarre
        sleep 10
        
        # Tester le health endpoint (devrait échouer car pas de modèle réel, mais conteneur doit tourner)
        docker logs test-app
        
        docker stop test-app
        docker rm test-app

  deploy:
    name: Deploy to Server
    needs: [build, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v3
    
    - name: Create deployment .env file
      run: |
        cat > deploy.env << EOF
        MLFLOW_TRACKING_URI=${{ secrets.MLFLOW_TRACKING_URI }}
        MLFLOW_TRACKING_USERNAME=${{ secrets.MLFLOW_TRACKING_USERNAME }}
        MLFLOW_TRACKING_PASSWORD=${{ secrets.MLFLOW_TRACKING_PASSWORD }}
        MODEL_NAME=mnist-classifier
        PORT=5000
        MLFLOW_S3_ENDPOINT_URL=${{ secrets.MLFLOW_S3_ENDPOINT_URL }}
        AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        EOF
    
    - name: Setup SSH
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock
      run: |
        mkdir -p ~/.ssh
        ssh-agent -a $SSH_AUTH_SOCK > /dev/null
        ssh-keyscan ${{ secrets.REMOTE_IP_ADDRESS }} >> ~/.ssh/known_hosts
        ssh-add - <<< "${{ secrets.PRIVATE_KEY }}"

    - name: Prepare remote server
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_IP_ADDRESS }} << 'ENDSSH'
          cd /home//${{ secrets.REMOTE_USER }}
          sudo mkdir -p deep_learning deep_learning/${{ env.CONTAINER_NAME }}
          sudo chown -R ${{ secrets.REMOTE_USER }}:${{ secrets.REMOTE_USER }} deep_learning/
        ENDSSH
    
    - name: Copy deployment files to server
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock
      run: |
        scp -o StrictHostKeyChecking=no deploy.env \
          ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_IP_ADDRESS }}:/home/${{ secrets.REMOTE_USER }}/deep_learning/${{ env.CONTAINER_NAME }}/
    
    - name: Deploy on Server
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_IP_ADDRESS }} << 'ENDSSH'
          cd /home/${{ secrets.REMOTE_USER }}/deep_learning/${{ env.CONTAINER_NAME }}/
          
          # Login to GitHub Container Registry
          echo ${{ secrets.GITHUB_TOKEN }} | sudo docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          
          # Stop and remove old container
          sudo docker stop ${{ env.CONTAINER_NAME }}
          sudo docker rm -f ${{ env.CONTAINER_NAME }}

          # delete old image
          sudo docker rmi -f ${{ needs.build.outputs.image_name }}
          
          # Pull latest image
          sudo docker pull ${{ needs.build.outputs.image_name }}
          
          # Run new container
          sudo docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            --restart unless-stopped \
            --env-file deploy.env \
            -p 5001:5000 \
            ${{ needs.build.outputs.image_name }}
          
          # Wait for container to be healthy
          sleep 10
          
          # Check health
          curl -f http://localhost:5000/health || exit 1
          
          echo "✓ Deployment successful!"
        ENDSSH
    
    - name: Verify Deployment
      env:
        SSH_AUTH_SOCK: /tmp/ssh_agent.sock
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_IP_ADDRESS }} << 'ENDSSH'
          # Check container status
          sudo docker ps | grep ${{ env.CONTAINER_NAME }}
          
          # Check logs
          sudo docker logs ${{ env.CONTAINER_NAME }} --tail 50
          
          # Test health endpoint
          curl http://localhost:5000/health
          
          # Test model info endpoint
          curl http://localhost:5000/model/info
        ENDSSH
